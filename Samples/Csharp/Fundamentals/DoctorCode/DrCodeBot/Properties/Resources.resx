<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CHOICE_GREET" xml:space="preserve">
    <value>greet a user</value>
  </data>
  <data name="CHOICE_HELP" xml:space="preserve">
    <value>build help options</value>
  </data>
  <data name="CHOICE_TYPING" xml:space="preserve">
    <value>show delay indicators</value>
  </data>
  <data name="FACE_IMAGE_URL" xml:space="preserve">
    <value>http://drcodebotnodejs.azurewebsites.net/assets/2x1_bust_shot.png</value>
  </data>
  <data name="GREET" xml:space="preserve">
    <value>Welcome! I am Doctor Code. I am here to teach you few basic things about building a Skype bot. What do you want to learn today?</value>
  </data>
  <data name="GREET_CODE" xml:space="preserve">
    <value>&lt;pre&gt;private Activity HandleSystemMessage(Activity message, ConnectorClient connectorClient)
{
    if (message.Type == ActivityTypes.ContactRelationUpdate)
    {
        // send a welcome message when the user adds the bot
        if (message.Action == ContactRelationUpdateActionTypes.Add)
        {
            Activity welcome = message.CreateReply();
            welcome.Attachments.Add(CardFactory.getWelcomeCard().ToAttachment());
            connectorClient.Conversations.ReplyToActivity(welcome);
        }
    }
    return null;
}&lt;/pre&gt;</value>
  </data>
  <data name="GREET_EXPLAIN" xml:space="preserve">
    <value>The contact relation update event notifies the bot that a user had added the bot to the contact list. In MessageController class, Post method sees if the type of the activity is of system message, and delegates the message to the HandleSystemMessage method where we check its activity type. If the message type is a Contact Relation Update, we check if it is an "add" action and create a reply to send it to the users.</value>
  </data>
  <data name="GREET_INTRO" xml:space="preserve">
    <value>Bot should introduce itself to the user and give an excellent first impression. Let's learn how to greet a user on the first run.</value>
  </data>
  <data name="GREET_MORE" xml:space="preserve">
    <value>To learn more, read &lt;a href="https://docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-activities"&gt;Activities overview&lt;/a&gt;.</value>
  </data>
  <data name="GREET_TRY_MSG" xml:space="preserve">
    <value>I sent you this greeting when we met for the first time. Let's look into the code!</value>
  </data>
  <data name="HELP" xml:space="preserve">
    <value>You can say or click 'greet a user', 'build help options', or 'show delay indicators' to learn how to add those functionalities to your bot.</value>
  </data>
  <data name="HELP_CODE" xml:space="preserve">
    <value>&lt;pre&gt;protected override async Task&amp;lt;string&amp;gt; PrepareAsync(IActivity item, CancellationToken token)
{
    var message = item as IMessageActivity;
    if (message != null &amp;amp;&amp;amp; !string.IsNullOrWhiteSpace(message.Text))
    {
        if (message.Text.Equals(Resources.HELP_TRIGGER_TEXT, StringComparison.InvariantCultureIgnoreCase))
        {
            return message.Text;
        }
    }
    return null;
}&lt;/pre&gt;</value>
  </data>
  <data name="HELP_EXPLAIN" xml:space="preserve">
    <value>We use global message handlers to handle the "help" keyword. The code above shows how HelpDialog will be triggered in the HelpScorable class. Whenever the user sends the bot a message, PrepareAsync() method in HelpScorable class inspects to see if the message matches "help". If so, we return the message to be used for scoring, and PostAsync() of the Scorable with the highest score will be triggered. In our PostAsync() method, we add the HelpDialog to the Dialog stack so that it will become the active dialog.</value>
  </data>
  <data name="HELP_INTRO" xml:space="preserve">
    <value>Bot should provide help options to the user. Let's learn how to build these options.</value>
  </data>
  <data name="HELP_MORE" xml:space="preserve">
    <value>To learn more, read &lt;a href="https://docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-global-handlers"&gt;Implement global message handlers&lt;/a&gt;.</value>
  </data>
  <data name="HELP_TITLE" xml:space="preserve">
    <value>Help</value>
  </data>
  <data name="HELP_TRIGGER_TEXT" xml:space="preserve">
    <value>help</value>
  </data>
  <data name="HELP_TRY_MSG" xml:space="preserve">
    <value>Any time the user types in 'help', the message that you just received will be sent to assist users. Let's look into the code!</value>
  </data>
  <data name="NAME" xml:space="preserve">
    <value>Doctor Code</value>
  </data>
  <data name="TYPING_CODE" xml:space="preserve">
    <value>&lt;pre&gt;// Send the typing indicator for few seconds (10 sec)
IMessageActivity typingIndicatorMessage = context.MakeMessage();
typingIndicatorMessage.Type = ActivityTypes.Typing;
typingIndicatorMessage.Text = null;
await context.PostAsync(typingIndicatorMessage);
await Task.Delay(10000);&lt;/pre&gt;</value>
  </data>
  <data name="TYPING_EXPLAIN" xml:space="preserve">
    <value>The code above in TypingButtonClickDialog's StartAsync method, sends the activity of type Typing to the user, which will show the typing indicator to the user. The typing indicator clears out when the bot sends a message.</value>
  </data>
  <data name="TYPING_INTRO" xml:space="preserve">
    <value>For time consuming operations, you want to visually inform user that the message from the bot is on its way. Let's learn how to use typing indicators.</value>
  </data>
  <data name="TYPING_MORE" xml:space="preserve">
    <value>To learn more, read &lt;a href="https://docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-activities" &gt;Activities overview&lt;/a&gt;.</value>
  </data>
  <data name="TYPING_TRY_MSG_1" xml:space="preserve">
    <value>Let's try it out! I will indicate that I am typing for 10 seconds.</value>
  </data>
  <data name="TYPING_TRY_MSG_2" xml:space="preserve">
    <value>Let's look into the code!</value>
  </data>
</root>